#include <iostream>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <math.h>
#include <pthread.h>

using namespace std;


int _maxToken,_flowInterval;

class Queue
{
    public:
        Queue (){
            start = 0;
            end = 0;
            sequenceNum = 0;
        }

        int len(){
            return end - start;
        }

        int enqueue(int num){
            end += num;
            sequenceNum += num;

            if (len() > 50){
                int length = len();
                end = start+50;
                return length - end;
            }
            return 0;
        }
        
        int dequeue(int num){
            if (start + num > end ){
                int servedCount = end - start;
                start = end;
                return servedCount;
            }else{
                start += num;
                return num;
            }
        }

        int back(){
            return sequenceNum - 1;
        }
    private:
        int start;
        int end;
        int sequenceNum;
        

};

struct ParameterPasser
{
    int MaxToken;
    Queue *q;
};

int servedToken = 0;
int totalDropped =0;
int totalFetched=0;
int totalGenerated = 0;
static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;

//TODO: fix problem of over dropped
void *flowSubroutine(void *queue)
{
    int temp;
    int s;
    // int totalDropped = 0;
    // int totalGenerated = 0;
    while (servedToken < _maxToken)
    {
        sleep(_flowInterval);

        int randNum = floor( rand()%10 +1  );

        s = pthread_mutex_lock(&mtx);

        Queue * tokenQ =  ((Queue*)queue);

        int dropped = tokenQ->enqueue(randNum);
        totalGenerated += randNum;
        servedToken += dropped;
        totalDropped += dropped;
        if (servedToken > _maxToken){
            int diffToken = servedToken - _maxToken;
            totalDropped -= diffToken;
            servedToken = _maxToken;
        }

        cout << randNum <<"\t\t" << tokenQ->back() << "\t\t\t"<< tokenQ->len()  << endl;
        // cout << "Flow Wake Up. Generated : " << randNum <<", Dropped :" <<dropped << ", queueLen : " <<tokenQ->len()<< endl;
        s = pthread_mutex_unlock(&mtx);
    }
    pthread_exit(0);
}

void *serverSubroutine(void *queue)
{
    int s;
    while (servedToken < _maxToken)
    {
        sleep(2);
        s = pthread_mutex_lock(&mtx);
        
        int randNum = floor( rand()%20 +1  );


        Queue * tokenQ =  ((Queue*)queue);

        if (randNum + servedToken > _maxToken){
            randNum = _maxToken - servedToken;
        }

        int served = tokenQ->dequeue(randNum);
        servedToken += served;
        totalFetched += served;

        // cout << "Server Wake Up. Generated : " << randNum <<", Dropped :" <<served << ", queueLen : " <<tokenQ->len() << endl;
        // printf("%-16i%-26i%-20i\n",tokenQ->len(),served,totalFetched);
        cout << "\t\t\t\t\t"<<tokenQ->len() << "\t\t" << served <<"\t\t" << totalFetched << endl;
        s = pthread_mutex_unlock(&mtx);
        
    }
    pthread_exit(0);
}


void initThreads()
{
    pthread_t flow_thread, server_thread;

    int *c;
    float *d;
    void *a[] = {c, d};


    Queue *q = new Queue();

    pthread_create(&server_thread, NULL, serverSubroutine, q);
    pthread_create(&flow_thread, NULL, flowSubroutine, q);

    pthread_join(server_thread, NULL);
    pthread_join(flow_thread, NULL);

    cout << "The total number of tokens that have been fetched by the server is "<<totalFetched << endl;
    cout << "The total number of tokens that have been generated by the flow is "<< totalGenerated << endl;
    cout << "The total number of tokens that have been dropped by the queue is "<< totalDropped << endl;

}

int main(int input_size, char **external_input)
{
    if (input_size > 2)
    {

        _maxToken = atoi(external_input[1]);
        _flowInterval =  atoi(external_input[2]);

        cout << "The Max Token is " << _maxToken << " and the interval time for flow is "<< _flowInterval << endl;
        cout << "Flow\t\t\t\t\tQueue\t\tServer" << endl; 
        cout << "Token added\tLast sequence number\tCurrent length\tToken fetched\tTotal Token fetched" << endl; 
        initThreads();
    }
    else
    {
        cout << "Please provide parameter prior starting.\nfirst(MaxToken) second(flowInterval)" << endl;
        exit(-1);
    }
    return 0;
}
