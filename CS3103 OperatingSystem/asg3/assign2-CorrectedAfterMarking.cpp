#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <string>
#include <pthread.h>
#include <unistd.h>	//sleep
#include <time.h>	//time(NULL)

using namespace std;

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

int servedToken = 0;
int maxToken, flowInterval;

class Que{
	int head, tail;
	int theQueue[55];	//purpose: store tokens values
	int numOfToks;	//length
	int dropped;
	public:
	Que(){
		head = tail = 0;
		numOfToks = 0;
		dropped = 0;
	}

	private:
	bool isEmpty(){
		return head == tail;
	}

	bool isFull(){
		return numOfToks>50;
	}

	public:
	void store(int tokens){
		if (isFull()) return;
		if(tokens+numOfToks>50){
			int dropping = tokens - (50-numOfToks);
			tokens -= dropping;
			dropped += dropping;
			servedToken += dropping;	//served if dropped due to buffer overflow
		}

		theQueue[tail] = tokens;
		tail = (tail+1)%50;
		numOfToks += tokens;
	}

	int getNTokens(int n){
		if(isEmpty()) return 0;
		int toks = 0;	//Tokens that the queue giving away

		if(n >= numOfToks){
			//Take all tokens
			toks = numOfToks;
			head = tail = 0;
		}
		else{
			do{
				if(theQueue[head] > n-toks){
					toks += n-toks;
					theQueue[head] -= toks;
				}
				else{
					toks += theQueue[head];
					head = (head+1)%50;
				}
			}while(toks<n);
		}

		numOfToks -= toks;
		return toks;
	}

	int getLength(){
		return numOfToks;
	}

	int getDropped(){
		return dropped;
	}
};

int genRand(int to){
	return rand()%to+1;	// [1,to]
}

void* flow(void *q){
	Que *queue = *(Que**) q;

	int lastSeqNum = -1;
	long tokenGened = 0;

	while(servedToken<maxToken){
		sleep(flowInterval);
		if(servedToken>=maxToken) break;

		bool lockOK = pthread_mutex_lock(&mutex);
		if(lockOK!=0){
			cout << "Mutex lock error!" << endl;
			exit(-1);
		}
		int added = genRand(10);

		if(added+servedToken>maxToken)
			added = maxToken - servedToken;

		lastSeqNum += added;
		tokenGened +=added;

		queue->store(added);
		cout<<added<<"\t\t"<<lastSeqNum<<"\t\t\t"<<queue->getLength()<<endl;
		bool unlockOK = pthread_mutex_unlock(&mutex);
		if(unlockOK!=0){
			cout << "Mutex unlock error!" << endl;
			exit(-1);
		}

	}
	pthread_exit((void *) tokenGened);
}

void* server(void *q){
	Que *queue = *(Que**) q;

	long totalFetched = 0;

	while(servedToken<maxToken){
		sleep(2);	//Wake up every 2 seconds
		if(servedToken>=maxToken) break;
		
		bool lockOK = pthread_mutex_lock(&mutex);
		if(lockOK!=0){
			cout << "Mutex lock error!" << endl;
			exit(-1);
		}
		
		int tokens = genRand(20);
		if(tokens+servedToken>maxToken)
			tokens = maxToken - servedToken;

		int fetch = queue->getNTokens(tokens);

		totalFetched += fetch;
		servedToken += fetch;

		cout<<"\t\t\t\t\t"<<queue->getLength()<<"\t\t"<<fetch<<"\t\t\t"<<totalFetched<<endl;
		pthread_mutex_unlock(&mutex);
		bool unlockOK = pthread_mutex_unlock(&mutex);
		if(unlockOK!=0){
			cout << "Mutex unlock error!" << endl;
			exit(-1);
		}
	}

	pthread_exit((void *) totalFetched);
}


void printFields(){
	cout<<"Flow\t\t\t\t\t";
	cout<<"Queue\t\t";
	cout<<"Server"<<endl;

	//Flow
	cout<<"Token added\tLast sequence number\t";
	//Queue
	cout<<"Current Length\t";
	//Server
	cout<<"Token fetched\t Total Token fetched"<<endl;
}

//Main thread
int main(int argc, char *argv[]){
	srand (time(NULL));	//Seed

	if(argc!=1+2){
		cout<<"ERROR: Please provide 2 arguments. (MaxToken, flowInterval)"<<endl;
		return -1;
	}

	maxToken = atoi(argv[1]);
	flowInterval = atoi(argv[2]);

	printf("The Max Token is %d and the interval time for flow is %d\n"
	,maxToken, flowInterval);

	printFields();

	//Initialize the queue
	Que *queue = new Que();

	//Create threads
	pthread_t threads[2];
	int rc1 = pthread_create(&threads[0], NULL, flow, (void *)(&queue) );
	int rc2 = pthread_create(&threads[1], NULL, server, (void *)(&queue));

	if(rc1||rc2) {
		cout << "Error when creating thread!" << endl;
		exit(-1);
	}

	//Join threads
	int rc;
	void *flowGened, *serverFetched;
	rc = pthread_join(threads[0], &flowGened);
	if (rc) {
		cout << "Error when joining thread!" << endl;
		exit(-1);
	}
	rc = pthread_join(threads[1], &serverFetched);
	if (rc) {
		cout << "Error when joining thread!" << endl;
		exit(-1);
	}

	//Simulation stopped. Print statistic.
	string ttnotthb = "The total number of tokens that have been ";
	cout<<ttnotthb<<"generated by the flow is "<<(long) flowGened<<endl;
	cout<<ttnotthb<<"fetched by the server is "<<(long) serverFetched<<endl;
	cout<<ttnotthb<<"dropped by the queue is "<<queue->getDropped()<<endl;
	cout<<ttnotthb<<"served is "<<servedToken<<endl;
	pthread_exit(NULL);
	return 0;
}
